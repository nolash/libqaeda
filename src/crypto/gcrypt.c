#ifdef LQ_GPG

#define GPG_MIN_VERSION "1.10.2"
#define GPG_KEY_TYP 1

#include <gcrypt.h>
#include <rerr.h>
#include <llog.h>
#include <hex.h>

#include "lq/crypto.h"
#include "lq/io.h"
#include "lq/mem.h"
#include "lq/config.h"
#include "lq/err.h"
#include "lq/store.h"
#include "lq/base.h"
#include "debug.h"

#define CHACHA20_KEY_LENGTH_BYTES 32
#define CHACHA20_NONCE_LENGTH_BYTES 12
#define POLY1305_MAC_LEN 16
#define POLY1305_MAC_KEYLEN 32

/// Lookup mode for key in store.
enum gpg_find_mode_e {
	GPG_FIND_MAIN, ///< Use default key filename.
	GPG_FIND_ORCREATE, ///< Create a new key if not found.
	GPG_FIND_FINGERPRINT, ///< Load only the key matching the fingerprint.
};

extern char zeros[65];

/**
 * gcrypt implementation of the crypto interface.
 *
 * The same structure is used in both LQPrivKey and LQPubKey.
 *
 */
struct gpg_store {
	gcry_sexp_t k; ///< S-expression representing the current object type.
	char fingerprint[LQ_FP_LEN]; ///< Fingerprint, used for LQPubKey.
	char public_key[LQ_PUBKEY_LEN]; ///< Literal, uncompressed public key bytes. Used in LQPubKey.
	char last_signature[LQ_SIGN_LEN]; ///< Stores the latest signature data generated by lq_privatekey_sign.
	char last_data[LQ_DIGEST_LEN]; ///< Stores the last digest data that was signed using lq_privatekey_sign.
};

/// store gpg library version.
static char *gpg_version = NULL;

/// directory holding crypto keys.
static int gpg_cfg_idx_dir;

/// default digest id.
static int gpg_passphrase_digest = GCRY_MD_SHA512;

/// zero fp value
const static char gpg_fingerprint_zero[LQ_FP_LEN];

const static char gpg_default_store_key;

static LQStore *gpg_key_store;

/**
 * Verifies that installed gpg version is supported.
 * Sets up crypto keys dir and sets passphrase digest length.
 *
 * \todo replace path massage with cwalk lib
 */
int lq_crypto_init(const char *base) {
	int r;
	int l = 0;
	char *p;
	char path[LQ_PATH_MAX];

	lq_zero(path, LQ_PATH_MAX);
	if (gpg_version == NULL) {
		gpg_version = (char*)gcry_check_version(GPG_MIN_VERSION);
		if (gpg_version == NULL) {
			return debug_logerr(LLOG_ERROR, ERR_NOCRYPTO, "broken");
		}
		gcry_control (GCRYCTL_INITIALIZATION_FINISHED, 0);
		if (!gcry_control (GCRYCTL_INITIALIZATION_FINISHED_P)) {
			return debug_logerr(LLOG_ERROR, ERR_NOCRYPTO, "init gcrypt");
		}
	}
	debug_x(LLOG_DEBUG, "gpg", "using gpg", 1, MORGEL_TYP_STR, 0, "version", gpg_version);

	gpg_cfg_idx_dir = lq_config_register(LQ_TYP_STR, "CRYPTODIR");

	p = path;
	l = strlen(base);
	lq_cpy(p, base, l);
	if (path[l] != '/') {
		path[l] = '/';
		path[l+1] = 0;
	}

	r = lq_config_set(gpg_cfg_idx_dir, path);
	if (r) {
		return ERR_FAIL;
	}
	gpg_key_store = lq_store_new(path);
	if (gpg_key_store == NULL) {
		return ERR_STORE_AVAIL;
	}

	return ERR_OK;
}

size_t get_padsize(size_t insize, size_t blocksize) {
	size_t c;
	size_t l;
	size_t m;

	c = insize + 1;
	l = c / blocksize;
	m = c % blocksize;
	if (m) {
		l++;
	}
	return l * blocksize;
}

static void padb(char *data, size_t outsize, size_t insize) {
	gcry_randomize(data + insize, outsize - insize, GCRY_STRONG_RANDOM);
}

static void pad(char *indata_raw, size_t outsize, const char *indata) { //std::string indata) {
	int l;

	strcpy(indata_raw, indata);
	l = strlen(indata) + 1;
	padb(indata_raw, outsize, l);
}

static int create_handle(gcry_cipher_hd_t *h, const char *key, const char *nonce) {
	const char *p;
	gcry_error_t e;

	e = gcry_cipher_open(h, GCRY_CIPHER_CHACHA20, GCRY_CIPHER_MODE_POLY1305, GCRY_CIPHER_SECURE);
	if (e) {
		p = gcry_strerror(e);
		return debug_logerr(LLOG_ERROR, ERR_FAIL, (char*)p);
	}
	e = gcry_cipher_setkey(*h, key, CHACHA20_KEY_LENGTH_BYTES);
	if (e) {
		return ERR_FAIL;
	}
	e = gcry_cipher_setiv(*h, nonce, CHACHA20_NONCE_LENGTH_BYTES);
	if (e) {
		return ERR_FAIL;
	}
	return ERR_OK;
}


static void free_handle(gcry_cipher_hd_t *h) {
	gcry_cipher_close(*h);
}

// Puts mac in mac and newly generated mac key in mac_key
// in is a buffer of in_len which must be cipher blocksize.
// no data validation checking is done.
static int create_mac(char *mac, char *mac_key, const char *in, size_t in_len) {
	int r;
	char *p;
	size_t maclen;
	gcry_mac_hd_t h;
	gcry_error_t e;

	r = gcry_mac_open(&h, GCRY_MAC_POLY1305, 0, NULL);
	if (r) {
		return r;
	}

	e = gcry_mac_setkey(h, mac_key, POLY1305_MAC_KEYLEN);
	if (e) {
		gcry_mac_close(h);
		p = (char*)gcry_strerror(e);
		return debug_logerr(LLOG_ERROR, ERR_CIPHER, p);
	}

	e = gcry_mac_write(h, in, in_len);
	if (e) {
		gcry_mac_close(h);
		p = (char*)gcry_strerror(e);
		return debug_logerr(LLOG_ERROR, ERR_CIPHER, p);
	}

	maclen = POLY1305_MAC_LEN;
	e = gcry_mac_read(h, mac, &maclen);
	if (e) {
		gcry_mac_close(h);
		p = (char*)gcry_strerror(e);
		return debug_logerr(LLOG_ERROR, ERR_CIPHER, p);
	}

	gcry_mac_close(h);

	if (maclen != POLY1305_MAC_LEN) {
		p = (char*)gcry_strerror(e);
		return debug_logerr(LLOG_ERROR, ERR_CIPHER, p);
	}

	return ERR_OK;
}

static int verify_mac(char *mac, char *mac_key, const char *in, size_t in_len) {
	int r;
	char *p;
	size_t maclen;
	gcry_mac_hd_t h;
	gcry_error_t e;

	r = gcry_mac_open(&h, GCRY_MAC_POLY1305, 0, NULL);
	if (r) {
		return r;
	}

	e = gcry_mac_setkey(h, mac_key, POLY1305_MAC_KEYLEN);
	if (e) {
		gcry_mac_close(h);
		p = (char*)gcry_strerror(e);
		return debug_logerr(LLOG_ERROR, ERR_CIPHER, p);
	}

	e = gcry_mac_write(h, in, in_len);
	if (e) {
		gcry_mac_close(h);
		p = (char*)gcry_strerror(e);
		return debug_logerr(LLOG_ERROR, ERR_CIPHER, p);
	}

	maclen = POLY1305_MAC_LEN;
	e = gcry_mac_read(h, mac, &maclen);
	if (e) {
		gcry_mac_close(h);
		p = (char*)gcry_strerror(e);
		return debug_logerr(LLOG_ERROR, ERR_CIPHER, p);
	}

	e = gcry_mac_verify(h, mac, maclen);
	if (e) {
		gcry_mac_close(h);
		p = (char*)gcry_strerror(e);
		return debug_logerr(LLOG_ERROR, ERR_CIPHER, p);
	}

	gcry_mac_close(h);

	if (maclen != POLY1305_MAC_LEN) {
		p = (char*)gcry_strerror(e);
		return debug_logerr(LLOG_ERROR, ERR_CIPHER, p);
	}

	return ERR_OK;
}
int encryptb (char *ciphertext, size_t ciphertext_len, const char *indata, size_t indata_len, const char *key, const char *nonce) {
	const char *p;
	int r;
	gcry_cipher_hd_t h;
	gcry_error_t e;
	char indata_raw[ciphertext_len];

	r = create_handle(&h, key, nonce);
	if (r) {
		return debug_logerr(LLOG_ERROR, ERR_CIPHER, "encrypt handle (bin)");
	}
	lq_cpy(indata_raw, indata, indata_len);
	padb(indata_raw, ciphertext_len, indata_len);
	e = gcry_cipher_encrypt(h, (unsigned char*)ciphertext, ciphertext_len, (const unsigned char*)indata_raw, ciphertext_len);
	if (e) {
		free_handle(&h);
		p = gcry_strerror(e);
		return debug_logerr(LLOG_ERROR, ERR_CIPHER, (char*)p);
	}

	free_handle(&h);


	return ERR_OK;
}

int encrypt(char *ciphertext, size_t ciphertext_len, const char *indata, const char *key, const char *nonce) {
	char *p;
	int r;
	gcry_cipher_hd_t h;
	gcry_error_t e;
	char indata_raw[ciphertext_len];

	r = create_handle(&h, key, nonce);
	if (r) {
		return debug_logerr(LLOG_ERROR, ERR_CIPHER, "encrypt handle (str)");
	}

	pad(indata_raw, ciphertext_len, indata);
	e = gcry_cipher_encrypt(h, (unsigned char*)ciphertext, ciphertext_len, (const unsigned char*)indata_raw, ciphertext_len);
	if (e) {
		free_handle(&h);
		p = (char*)gcry_strerror(e);
		return debug_logerr(LLOG_ERROR, ERR_CIPHER, p);
	}

	free_handle(&h);

	return ERR_OK;
}

int decryptb(char *outdata, const char *ciphertext, size_t ciphertext_len, const char *key, const char *nonce) {
	char *p;
	int r;
	gcry_cipher_hd_t h;
	gcry_error_t e;

	r = create_handle(&h, key, nonce);
	if (r) {
		return debug_logerr(LLOG_ERROR, ERR_CIPHER, "decrypt handle (bin)");
	}

	e = gcry_cipher_decrypt(h, outdata, ciphertext_len, ciphertext, ciphertext_len);
	if (e) {
		free_handle(&h);
		p = (char*)gcry_strerror(e);
		return debug_logerr(LLOG_ERROR, ERR_CIPHER, p);
	}

	free_handle(&h);

	return ERR_OK;
}

int decrypt(char *outdata, const char *ciphertext, size_t ciphertext_len, const char *key, const char *nonce) {
	char *p;
	int r;
	gcry_cipher_hd_t h;
	gcry_error_t e;

	r = create_handle(&h, key, nonce);
	if (r) {
		return debug_logerr(LLOG_ERROR, ERR_CIPHER, "decrypt handle (str)");
	}

	e = gcry_cipher_decrypt(h, outdata, ciphertext_len, ciphertext, ciphertext_len);
	if (e) {
		free_handle(&h);
		p = (char*)gcry_strerror(e);
		return debug_logerr(LLOG_ERROR, ERR_CIPHER, p);
	}

	free_handle(&h);

	return ERR_OK;
}


// DIGEST SECTION

/// Calculate a digest according to the specified algo.
static int calculate_digest_algo(const char *in, size_t in_len, char *out, enum gcry_md_algos algo) {
	gcry_error_t e;
	gcry_md_hd_t h;
	unsigned char *v;
	static unsigned int digest_len;

	if (algo == GCRY_MD_NONE) {
		algo = GCRY_MD_SHA512;
	}

	e = gcry_md_open(&h, algo, GCRY_MD_FLAG_SECURE);
	if (e) {
		return ERR_ENCODING;
	}
	e = gcry_md_enable(h, algo);
	if (e) {
		return ERR_COMPAT;
	}
	digest_len = gcry_md_get_algo_dlen(algo);

	gcry_md_write(h, in, in_len);
	v = gcry_md_read(h, 0);
	lq_cpy(out, v, digest_len);
	gcry_md_close(h);
	return ERR_OK;
}

/// Calculate digest using the default hashing algorithm (SHA256)
/// using the gcrypt library.
int lq_digest(const char *in, size_t in_len, char *out) {
	return calculate_digest_algo(in, in_len, out, GCRY_MD_NONE);
}


/// Apply public key to the gpg_store struct.
static int key_apply_public(struct gpg_store *gpg) {
	char *p;
	size_t c;
	gcry_sexp_t one;
	gcry_sexp_t two;

	one = gcry_sexp_find_token(gpg->k, "public-key", 10);
	if (one == NULL) {
		return debug_logerr(LLOG_ERROR, ERR_KEYFAIL, "sexp pubkey");
	}
	two = gcry_sexp_find_token(one, "q", 1);
	if (two == NULL) {
		gcry_sexp_release(one);
		return debug_logerr(LLOG_ERROR, ERR_KEYFAIL, "sexp q");
	}
	c = LQ_PUBKEY_LEN;
	p = (char*)gcry_sexp_nth_data(two, 1, &c);
	if (p == NULL) {
		gcry_sexp_release(two);
		gcry_sexp_release(one);
		return debug_logerr(LLOG_ERROR, ERR_KEYFAIL, "sexp first data");
	}

	lq_cpy(gpg->public_key, p, LQ_PUBKEY_LEN);
	gcry_sexp_release(two);
	gcry_sexp_release(one);
	p = (char*)gcry_pk_get_keygrip(gpg->k, (unsigned char*)gpg->fingerprint);
	if (p == NULL) {
		return debug_logerr(LLOG_ERROR, ERR_KEYFAIL, "pubkey fingerprint");
	}

	return ERR_OK;
}

/// Create a new gcrypt keypair.
static int key_create(struct gpg_store *gpg) {
	int r;
	const char *p;
	const char *sexp_quick = "(genkey(ecc(flags eddsa)(curve Ed25519)))";
	gcry_sexp_t in;
	gcry_error_t e;

	// Set up parameters for key creation.
	e = gcry_sexp_new(&in, (const void*)sexp_quick, strlen(sexp_quick), 0);
	if (e) {
		p = gcry_strerror(e);
		return debug_logerr(LLOG_ERROR, ERR_KEYFAIL, (char*)p);
	}

	// Generate a new key with the given parameters.
	e = gcry_pk_genkey(&gpg->k, in);
	if (e) {
		gcry_sexp_release(in);
		p = gcry_strerror(e);
		return debug_logerr(LLOG_ERROR, ERR_KEYFAIL, (char*)p);
	}
	gcry_sexp_release(in);

	// Apply the public part of the key to the underlying key structure.
	r = key_apply_public(gpg);
	if (r) {
		return debug_logerr(LLOG_ERROR, ERR_KEYFAIL, "private create apply public");
	}

	return ERR_OK;
}

static LQStore *key_store_get() {
	return gpg_key_store;
}

/**
 * \todo consistent endianness for key length in persistent storage (fwrite)
 * \todo doc must have enough in path for path + fingerprint hex
 * \todo check capacity in buffer for both ciphertext, nonce and mac.
 */
static int key_create_store(struct gpg_store *gpg, const char *passphrase, size_t passphrase_len) {
	char *p;
	int r;
	int kl;
	char v[LQ_CRYPTO_BUFLEN];
	int l;
	size_t c;
	size_t m;
	LQStore *store;
	LQPubKey *pubk;
	char nonce[CHACHA20_NONCE_LENGTH_BYTES];
	char buf_key[LQ_STORE_KEY_MAX];
	char buf_val[LQ_STORE_VAL_MAX];
	char ciphertext[LQ_CRYPTO_BUFLEN];
	char passphrase_hash[LQ_DIGEST_LEN];
	char mac[POLY1305_MAC_LEN];

	// Initialize to assist debugging.
	lq_zero(buf_key, LQ_STORE_KEY_MAX);
	lq_zero(buf_val, LQ_STORE_VAL_MAX);

	// Create the private key and corresponding public key.
	r = key_create(gpg);
	if (r) {
		return debug_logerr(LLOG_ERROR, ERR_KEYFAIL, "key create");
	}
	
	// Export the S-expression to a text buffer for saving, canonical formatting
	kl = gcry_sexp_sprint(gpg->k, GCRYSEXP_FMT_CANON, NULL, 0);
	m = (size_t)kl + 1;
	p = (char*)v + sizeof(int);
	c = 0;
	kl = gcry_sexp_sprint(gpg->k, GCRYSEXP_FMT_CANON, p, LQ_CRYPTO_BUFLEN - m);
	m -= (size_t)(kl + 1);
	c += kl;
	lq_cpy(v, &c, sizeof(int));

	// Pad the contents up to the blocksize boundary
	m = c;
	c = get_padsize(m, LQ_CRYPTO_BLOCKSIZE);

	// Hash the encryption key to the expected length.
	r = calculate_digest_algo(passphrase, passphrase_len, passphrase_hash, gpg_passphrase_digest);
	if (r) {
		return debug_logerr(LLOG_ERROR, ERR_DIGEST, "passphrase hash");
	}

	// Encrypt the payload with the passphrase and nonce.
	gcry_create_nonce(nonce, CHACHA20_NONCE_LENGTH_BYTES);
	r = encryptb(ciphertext, c, v, m+sizeof(int), passphrase_hash, nonce);
	if (r) {
		return debug_logerr(LLOG_ERROR, ERR_KEY_LOCK, "encrypt private key");
	}

	c += CHACHA20_NONCE_LENGTH_BYTES;
	r = create_mac(mac, passphrase_hash + CHACHA20_KEY_LENGTH_BYTES, v, m+sizeof(int));
	if (r) {
		return debug_logerr(LLOG_ERROR, ERR_CIPHER, "mac generation fail");
		return r;
	}
	lq_cpy(ciphertext + c, mac, POLY1305_MAC_LEN);

	// Export the key (fingerprint) and value (ciphertext) to put in the store.
	// (We don't need the inner private key pointer anymore, so we re-use it.)
	pubk = lq_publickey_new(gpg->public_key);
	if (pubk == NULL) {
		return debug_logerr(LLOG_ERROR, ERR_KEYFAIL, "publickey");
	}
	gpg = (struct gpg_store*)pubk->impl;
	lq_cpy(buf_key, gpg->fingerprint, LQ_FP_LEN);
	lq_cpy(buf_val, nonce, CHACHA20_NONCE_LENGTH_BYTES);
	lq_cpy(buf_val + CHACHA20_NONCE_LENGTH_BYTES, ciphertext, c);
	lq_cpy(buf_val + CHACHA20_NONCE_LENGTH_BYTES + c, mac, POLY1305_MAC_LEN);
	lq_publickey_free(pubk);

	// Retrieve the store.
	store = key_store_get();
	if (store == NULL) {
		return debug_logerr(LLOG_ERROR, ERR_KEYFILE, "create store");
	}

	// Write the ciphertext to the store.	
	l = c + POLY1305_MAC_LEN;
	c = LQ_FP_LEN;
	r = store->put(LQ_CONTENT_KEY, store, buf_key, &c, buf_val, l);
	if (r) {
		return debug_logerr(LLOG_ERROR, ERR_KEYFILE, "put key in store");
	}

	// Check if a main key already exists in the store.
	// If not, set this one as main.
	*buf_key = gpg_default_store_key;
	c = LQ_STORE_VAL_MAX; 
	r = store->get(LQ_CONTENT_KEY, store, buf_key, 1, buf_val, &c);
	if (r) {
		if (r != ERR_NOENT) {
			debug(LLOG_ERROR, "crypto.gcrypt", "no default");
			return debug_logerr(LLOG_ERROR, ERR_KEYFILE, "default key");
		}
		c = 1;
		r = store->put(LQ_CONTENT_KEY, store, buf_key, &c, buf_val, l);
		if (r) {
			debug(LLOG_ERROR, "crypto.gcrypt", "fail put default");
			return debug_logerr(LLOG_ERROR, ERR_KEYFILE, "write default key");
		}
	}

	return ERR_OK;
}

/// Create a new keypair, encrypted with given passphrase.
static LQPrivKey* privatekey_alloc(const char *passphrase, size_t passphrase_len) {
	int r;
	LQPrivKey *o;
	struct gpg_store *gpg;

	// Allocate private key structures.
	o = lq_alloc(sizeof(LQPrivKey));
	if (o == NULL) {
		return NULL;
	}
	gpg = lq_alloc(sizeof(struct gpg_store));
	if (gpg == NULL) {
		lq_free(o);
		return NULL;
	}

	// Create the underlying private key.
	r = key_create_store(gpg, passphrase, passphrase_len);
	if (r) {
		lq_free(gpg);
		lq_free(o);
		return NULL;
	}

	// Populate the internal key structure.
	o->impl = (void*)gpg;
	o->key_typ = GPG_KEY_TYP;
	o->key_state = LQ_KEY_INIT;

	// No cleanup = caller must free it.
	debug_x(LLOG_INFO, "gpg", "created new private key", 1, MORGEL_TYP_BIN, LQ_FP_LEN, "fingerprint", gpg->fingerprint);

	return o;
}


/// Implements the interface to create a new private key.
LQPrivKey* lq_privatekey_new(const char *passphrase, size_t passphrase_len) {
	int r;
	LQPrivKey *o;
	if (passphrase == NULL) {
		return NULL;
	}

	o = privatekey_alloc(passphrase, passphrase_len);
	if (o == NULL) {
		return NULL;
	}
	r = lq_privatekey_lock(o, passphrase, passphrase_len);
	if (r) {
		return NULL;
	}
	return o;
}

/// Parse data from buffer as S-expression text representing a key.
static int key_from_data(gcry_sexp_t *key, const char *indata, size_t indata_len) {
	gcry_error_t e;

	e = gcry_sexp_new(key, indata, indata_len, 0);
	if (e != GPG_ERR_NO_ERROR) {
		return debug_logerr(LLOG_ERROR, ERR_COMPAT, "not key data");
	}
	return ERR_OK;
}

static int check_ciphertext(const char *buf, size_t buf_len) {
	return buf_len % (LQ_CRYPTO_BLOCKSIZE + CHACHA20_NONCE_LENGTH_BYTES + POLY1305_MAC_LEN);
}

/// Load a private key from the store's crypto partition.
static int key_from_store(struct gpg_store *gpg, const char *passphrase, size_t passphrase_len) {
	char *nonce;
	char *p;
	int r;
	LQStore *store;
	char inkey[LQ_FP_LEN];
	size_t inkey_len;
	char out[LQ_CRYPTO_BUFLEN];
	char in[LQ_CRYPTO_BUFLEN];
	size_t in_len;
	size_t out_len;
	char passphrase_hash[LQ_DIGEST_LEN];

	// Instantiate the store.
	store = key_store_get();

	// If a valid fingerprint is found in the gpg structure,
	// retrieve the key matching that fingerprint.
	// Otherwise, retrieve the main key.
	// Or fail if none of them can be found.
	inkey_len = LQ_FP_LEN;
	in_len = LQ_CRYPTO_BUFLEN;
	if (lq_cmp(gpg->fingerprint, gpg_fingerprint_zero, LQ_FP_LEN)) {
		lq_cpy(inkey, gpg->fingerprint, LQ_FP_LEN);	
	} else {
		*inkey = gpg_default_store_key;
		inkey_len = 1;
	}
	r = store->get(LQ_CONTENT_KEY, store, inkey, inkey_len, in, &in_len);
	if (r) {
		return ERR_NOENT;
	}

	r = check_ciphertext(in, in_len);
	if (r) {
		return debug_logerr(LLOG_ERROR, ERR_CIPHER, "incorrect ciphertext");
	}

	// Hash the encryption key to the expected length.
	r = calculate_digest_algo(passphrase, passphrase_len, passphrase_hash, gpg_passphrase_digest);
	if (r) {
		return debug_logerr(LLOG_ERROR, ERR_DIGEST, "passphrase hash");
	}

	// Decrypt the private key data from the store
	// with the provided passphrase and the extracted nonce.
	nonce = in;
	p = (char*)in + CHACHA20_NONCE_LENGTH_BYTES;
	in_len -= CHACHA20_NONCE_LENGTH_BYTES;
	r = decryptb(out, p, in_len - POLY1305_MAC_LEN, passphrase_hash, nonce);
	if (r) {
		return ERR_KEY_UNLOCK;
	}

	r = verify_mac(p + in_len - POLY1305_MAC_LEN, passphrase_hash + CHACHA20_KEY_LENGTH_BYTES, out, in_len - POLY1305_MAC_LEN);
	if (r) {
		return ERR_KEY_UNLOCK;
	}

	// Attempt to parse and instantiate the key from the decrypted data.
	out_len = (size_t)(*((int*)out));
	p = (char*)(out+sizeof(int));
	r = key_from_data(&gpg->k, p, out_len);
	if (r) {
		return ERR_KEYFAIL;
	}

	return ERR_OK;
}

static int gpg_key_load(struct gpg_store *gpg, const char *passphrase, size_t passphrase_len, enum gpg_find_mode_e mode, const void *criteria) {
	int r;

	switch(mode) {
		case GPG_FIND_MAIN:
			r = key_from_store(gpg, passphrase, passphrase_len);
			if (r) {
				return debug_logerr(LLOG_WARNING, ERR_KEYFILE, "default key not found");
			}
			break;
		case GPG_FIND_ORCREATE:
			r = key_from_store(gpg, passphrase, passphrase_len);
			if (r == ERR_OK) {
				break;
			}
			// if no key could be loaded, attempt to create one.
			if (!lq_cmp(gpg_fingerprint_zero, gpg->fingerprint, LQ_FP_LEN)) {
				debug(LLOG_DEBUG, "gpg", "default private key not found, attempting create new");
				r = key_create_store(gpg, passphrase, passphrase_len);
				if (r) {
					return debug_logerr(LLOG_WARNING, ERR_KEYFILE, "create key when no default found");
				}
			}
			break;
		case GPG_FIND_FINGERPRINT:
			r = key_from_store(gpg, passphrase, passphrase_len);
			if (r) {
				return debug_logerr(LLOG_WARNING, ERR_KEYFILE, "fingerprint key not found");
			}
			break;
		default:
			return debug_logerr(LLOG_WARNING, ERR_FAIL, NULL);
	}

	r = key_apply_public(gpg);
	if (r) {
		return debug_logerr(LLOG_ERROR, ERR_KEYFAIL, "apply public key");
	}
	debug_x(LLOG_INFO, "gpg", "loaded private key", 1, MORGEL_TYP_BIN, LQ_FP_LEN, "fingerprint", gpg->fingerprint);
	
	return ERR_OK;
}


/// Implements the interface to load a private key from storage.
LQPrivKey* lq_privatekey_load(const char *passphrase, size_t passphrase_len, const char *fingerprint) {
	LQPrivKey *pk;
	enum gpg_find_mode_e m;
	struct gpg_store *gpg;
	int r;
	
	pk = lq_alloc(sizeof(LQPrivKey));
	if (pk == NULL) {
		debug_logerr(LLOG_ERROR, ERR_KEYFAIL, "allocate object");
		return NULL;
	}
	pk->impl = (struct gpg_store*)lq_alloc(sizeof(struct gpg_store));
	if (pk->impl == NULL) {
		lq_free(pk);
		debug_logerr(LLOG_ERROR, ERR_KEYFAIL, "allocate internal structure");
		return NULL;
	}
	lq_zero(pk->impl, sizeof(struct gpg_store));
	gpg = (struct gpg_store*)pk->impl;
	m = GPG_FIND_ORCREATE;
	if (fingerprint != NULL) {
		lq_cpy(gpg->fingerprint, fingerprint, LQ_FP_LEN);
		m = GPG_FIND_FINGERPRINT;
	}
	r = gpg_key_load(gpg, passphrase, passphrase_len, m, NULL);
	if (r) {
		lq_free(pk->impl);
		lq_free(pk);
		debug_logerr(LLOG_ERROR, ERR_KEYFAIL, "key load fail");
		return NULL;	
	}
	pk->key_typ = GPG_KEY_TYP;
	pk->key_state = LQ_KEY_INIT;

	return pk;
}

size_t lq_publickey_bytes(LQPubKey *pubk, char **out) {
	struct gpg_store *gpg;

	gpg = (struct gpg_store*)pubk->impl;
	*out = gpg->public_key;
	return LQ_PUBKEY_LEN;
}

int lq_privatekey_lock(LQPrivKey *pk, const char *passphrase, size_t passphrase_len) {
	if (pk == NULL) {
		return ERR_INIT;
	}
	if ((pk->key_state & LQ_KEY_LOCK) > 0) {
		return ERR_NOOP;
	}
	pk->key_state |= LQ_KEY_LOCK;
	return ERR_OK;
}

int lq_privatekey_unlock(LQPrivKey *pk, const char *passphrase, size_t passphrase_len) {
	char b;

	if (pk == NULL) {
		return ERR_INIT;
	}
	if ((pk->key_state & LQ_KEY_LOCK) == 0) {
		return ERR_NOOP;
	}
	b = LQ_KEY_LOCK;
	pk->key_state &= ~b;
	return ERR_OK;
}

// SIGNATURE SECTION
//
//int sign_with(struct gpg_store *gpg, char *data, size_t data_len, const char *passphrase, const char *fingerprint) {
//	int r;
//	size_t c;
//	gcry_sexp_t pnt;
//	gcry_sexp_t msg;
//	gcry_sexp_t sig;
//	gcry_error_t e;
//	char *p;
//
//
//	if (fingerprint == NULL) {
//		r = gpg_key_load(gpg, passphrase, KEE_GPG_FIND_MAIN, NULL);
//	} else {
//		r = gpg_key_load(gpg, passphrase, KEE_GPG_FIND_FINGERPRINT, fingerprint);
//	}
//	if (r) {
//		return 1;
//	}
//		 
//	c = 0;
//	e = gcry_sexp_build(&msg, &c, "(data(flags eddsa)(hash-algo sha512)(value %b))", 64, gpg->last_data);
//	if (e != GPG_ERR_NO_ERROR) {
//		return 1;
//	}
//}

static int sign(struct gpg_store *gpg, const char *data, size_t data_len, const char *salt) {
	int r;
	size_t c;
	char *p;
	gcry_sexp_t pnt;
	gcry_sexp_t msg;
	gcry_sexp_t sig;
	gcry_error_t e;

	lq_zero(&e, sizeof(gcry_error_t));
	r = calculate_digest_algo(data, data_len, gpg->last_data, GCRY_MD_SHA512);
	if (r) {
		return 1;
	}

	c = 0;
	e = gcry_sexp_build(&msg, &c, "(data(flags eddsa)(hash-algo sha512)(value %b))", 64, gpg->last_data);
	if (e != GPG_ERR_NO_ERROR) {
		return 1;
	}

	e = gcry_pk_sign(&sig, msg, gpg->k);
	if (e != GPG_ERR_NO_ERROR) {
		gcry_sexp_release(msg);
		return 1;
	}

	// retrieve r and write it
	pnt = NULL;
	pnt = gcry_sexp_find_token(sig, "r", 1);
	if (pnt == NULL) {
		gcry_sexp_release(sig);
		gcry_sexp_release(msg);
		return ERR_FAIL;
	}
	c = LQ_POINT_LEN;
	p = (char*)gcry_sexp_nth_data(pnt, 1, &c);
	if (p == NULL) {
		gcry_sexp_release(pnt);
		gcry_sexp_release(sig);
		gcry_sexp_release(msg);
		return ERR_SIGVALID;
	}
	lq_cpy(gpg->last_signature, p, c);

	// retrieve s and write it
	gcry_sexp_release(pnt);
	pnt = NULL;
	pnt = gcry_sexp_find_token(sig, "s", 1);
	if (pnt == NULL) {
		gcry_sexp_release(sig);
		gcry_sexp_release(msg);
		return ERR_FAIL;
	}
	c = LQ_POINT_LEN;
	p = (char*)gcry_sexp_nth_data(pnt, 1, &c);
	if (p == NULL) {
		gcry_sexp_release(pnt);
		gcry_sexp_release(sig);
		gcry_sexp_release(msg);
		return ERR_SIGVALID;
	}
	lq_cpy(gpg->last_signature + LQ_POINT_LEN, p, c);
	gcry_sexp_release(pnt);
	gcry_sexp_release(sig);
	gcry_sexp_release(msg);

	return ERR_OK;
}

LQSig* lq_privatekey_sign(LQPrivKey *pk, const char *data, size_t data_len, const char *salt) {
	int r;
	struct gpg_store *gpg;
	LQSig *sig;

	if ((pk->key_state & LQ_KEY_LOCK) > 0) {
		debug_logerr(LLOG_INFO, ERR_KEY_LOCK, "key locked");
		return NULL;
	}

	gpg = (struct gpg_store*)pk->impl;

	r = sign(gpg, data, data_len, salt);
	if (r != ERR_OK) {
		return NULL;
	}

	sig = lq_alloc(sizeof(LQSig));
	sig->pubkey = lq_publickey_from_privatekey(pk);
	if (sig->pubkey == NULL) {
		lq_signature_free(sig);
		return NULL;
	}
	sig->impl = lq_alloc(LQ_SIGN_LEN);
	lq_cpy(sig->impl, gpg->last_signature, LQ_SIGN_LEN);
	return sig;
}

LQSig* lq_signature_from_bytes(const char *sig_data, size_t sig_len, LQPubKey *pubkey) {
	LQSig *sig;

	if (!lq_cmp(sig_data, zeros, LQ_SIGN_LEN)) {
		return NULL;
	}

	sig = lq_alloc(sizeof(LQSig));
	lq_zero(sig, sizeof(LQSig));
	sig->impl = lq_alloc(LQ_SIGN_LEN);
	lq_cpy(sig->impl, sig_data, LQ_SIGN_LEN);
	return sig;
}

size_t lq_signature_bytes(LQSig *sig, char **out) {
	*out = sig->impl;
	return LQ_SIGN_LEN;
}

int lq_signature_verify(LQSig *sig, const char *data, size_t data_len) {
	const char *p;
	int r;
	size_t c;
	gcry_mpi_t sig_r;
	gcry_mpi_t sig_s;
	gcry_error_t e;
	gcry_sexp_t sigx;
	gcry_sexp_t msgx;
	gcry_sexp_t pubkey;
	struct gpg_store *gpg;
	char digest[LQ_DIGEST_LEN];

	if (sig->pubkey == NULL) {
		return ERR_NOENT;
	}

	gpg = (struct gpg_store*)sig->pubkey->impl;
	c = 0;
	e = gcry_sexp_build(&pubkey, &c, "(key-data(public-key(ecc(curve Ed25519)(q %b))))", LQ_PUBKEY_LEN, gpg->public_key);
	if (e != GPG_ERR_NO_ERROR) {
		return ERR_KEYFAIL;
	}

	c = 0;
	e = gcry_mpi_scan(&sig_r, GCRYMPI_FMT_STD, sig->impl, LQ_POINT_LEN, &c);
	if (e != GPG_ERR_NO_ERROR) {
		p = gcry_strerror(e);
		gcry_sexp_release(pubkey);
		return debug_logerr(LLOG_INFO, ERR_KEYFAIL, (char*)p);
	}
	if (c != 32) {
		p = gcry_strerror(e);
		gcry_mpi_release(sig_r);
		gcry_sexp_release(pubkey);
		return debug_logerr(LLOG_INFO, ERR_KEYFAIL, (char*)p);
	}

	c = 0;
	e = gcry_mpi_scan(&sig_s, GCRYMPI_FMT_STD, sig->impl + LQ_POINT_LEN, LQ_POINT_LEN, &c);
	if (e != GPG_ERR_NO_ERROR) {
		p = gcry_strerror(e);
		gcry_mpi_release(sig_r);
		gcry_sexp_release(pubkey);
		return debug_logerr(LLOG_INFO, ERR_KEYFAIL, (char*)p);
	}
	if (c != 32) {
		p = gcry_strerror(e);
		gcry_mpi_release(sig_s);
		gcry_mpi_release(sig_r);
		gcry_sexp_release(pubkey);
		return debug_logerr(LLOG_INFO, ERR_KEYFAIL, (char*)p);
	}

	c = 0;
	e = gcry_sexp_build(&sigx, &c, "(sig-val(eddsa(r %m)(s %m)))", sig_r, sig_s);
	if (e != GPG_ERR_NO_ERROR) {
		p = gcry_strerror(e);
		gcry_mpi_release(sig_s);
		gcry_mpi_release(sig_r);
		gcry_sexp_release(pubkey);
		return debug_logerr(LLOG_INFO, ERR_SIGFAIL, (char*)p);
	}
	gcry_mpi_release(sig_s);
	gcry_mpi_release(sig_r);

	r = calculate_digest_algo(data, data_len, digest, GCRY_MD_SHA512);
	if (r) {
		p = gcry_strerror(e);
		gcry_sexp_release(sigx);
		gcry_sexp_release(pubkey);
		return debug_logerr(LLOG_INFO, ERR_DIGEST, (char*)p);
	}

	c = 0;
	e = gcry_sexp_build(&msgx, &c, "(data(flags eddsa)(hash-algo sha512)(value %b))", LQ_DIGEST_LEN, digest);
	if (e != GPG_ERR_NO_ERROR) {
		p = gcry_strerror(e);
		gcry_sexp_release(sigx);
		gcry_sexp_release(pubkey);
		return debug_logerr(LLOG_INFO, ERR_DIGEST, (char*)p);
	}

	e = gcry_pk_verify(sigx, msgx, pubkey);
	if (e != GPG_ERR_NO_ERROR) {
		p = gcry_strerror(e);
		gcry_sexp_release(msgx);
		gcry_sexp_release(sigx);
		gcry_sexp_release(pubkey);
		return debug_logerr(LLOG_INFO, ERR_SIGVALID, (char*)p);
	}

	gcry_sexp_release(msgx);
	gcry_sexp_release(sigx);
	gcry_sexp_release(pubkey);

	return ERR_OK;
}

void lq_privatekey_free(LQPrivKey *pk) {
	struct gpg_store *gpg;

	gpg = (struct gpg_store*)pk->impl;
	gcry_sexp_release(gpg->k);
	lq_free(pk->impl);
	lq_free(pk);
}

void lq_publickey_free(LQPubKey *pubk) {
	struct gpg_store *gpg;

	gpg = (struct gpg_store*)pubk->impl;
	gcry_sexp_release(gpg->k);
	lq_free(pubk->impl);
	lq_free(pubk);
}

void lq_signature_free(LQSig *sig) {
	if (sig->pubkey != NULL) {
		lq_publickey_free(sig->pubkey);
	}
	if (sig->impl != NULL) {
		lq_free(sig->impl);
	}
	lq_free(sig);
}

LQPubKey* lq_publickey_from_privatekey(LQPrivKey *pk) {
	struct gpg_store *gpg;
	LQPubKey *pubk;

	gpg = (struct gpg_store*)pk->impl;
	pubk = lq_publickey_new(gpg->public_key);

	return pubk;
}

LQPubKey* lq_publickey_new(const char *full) {
	const char *p;
	const char *r;
	gcry_error_t e;
	size_t c;
	LQPubKey *pubk;
	struct gpg_store *gpg;

	gpg = lq_alloc(sizeof(struct gpg_store));
	lq_zero(gpg, sizeof(struct gpg_store));
	lq_cpy(gpg->public_key, full, LQ_PUBKEY_LEN);

	pubk = lq_alloc(sizeof(LQPubKey));
	lq_zero(pubk, sizeof(LQPubKey));

	c = 0;
	e = gcry_sexp_build(&gpg->k, &c, "(key-data(public-key(ecc(curve Ed25519)(q %b))))", LQ_PUBKEY_LEN, full);
	if (e != GPG_ERR_NO_ERROR) {
		p = gcry_strerror(e);
		debug_logerr(LLOG_DEBUG, ERR_KEYFAIL, (char*)p);
		return NULL;
	}

	r = (char*)gcry_pk_get_keygrip(gpg->k, (unsigned char*)gpg->fingerprint);
	if (r == NULL) {
		debug_logerr(LLOG_ERROR, ERR_KEYFAIL, "fingerprint fail");
		return NULL;
	}

	pubk->impl = (void*)gpg;
	pubk->key_typ = GPG_KEY_TYP;
	pubk->pk = NULL;

	return pubk;
}

size_t lq_publickey_fingerprint(LQPubKey* pubk, char **out) {
	struct gpg_store *gpg;

	gpg = (struct gpg_store*)pubk->impl;
	*out = gpg->fingerprint;
	return LQ_FP_LEN;
}

void lq_crypto_free() {
	//lq_store_free((void*)gpg_key_store);
	gpg_key_store->free(gpg_key_store);
	gpg_key_store = NULL;
	gpg_version = NULL;
}

#endif
